\section{Implementation}

In this chapter we will describe the overall architecture of \texttt{diffr} and \texttt{patchr} and provide a few implementation details. Then we will move on to describe the tools we used during the implementation.

\subsection{Modules}

\paragraph{diffr.suffix-tree (suffix-tree/)}
This module contains the Suffix Tree implementation. It is a generic Suffix Tree based on the implementation suggested in \cite{Ukkonen95} and optimised for quickly matching suffixes of elements. The implementation details are completely hidden from the user behind the \\ \texttt{diffr.suffixtree.SuffixTree} interface and \\ \texttt{diffr.suffixtree.SuffixTrees} factory. Using the \texttt{SuffixTree} for matching sequences of elements can be accomplished through an implementation of \texttt{diffr.suffixtree.SuffixTree.Matcher} interface returned from \\ \texttt{SuffixTree\#matcher()} method. Internally the Suffix Tree uses high-performance, real-time \texttt{java.util.List} and \texttt{java.util.Map} implementations from the \texttt{javolution library} (\texttt{javolution.util.FastTable} and \texttt{javolution.util.FastMap})~\cite{javolution}. 

The hashcode of each of line of the first document is computed and used first before a deep comparison of lines when attempting to find clones in the tree.
This improves performance slightly.

\paragraph{diffr.util (util/)}
This module contains various domain objects and utility classes. The main classes that encapsulate the two possible instructions output by \texttt{diffr} and are located in the \texttt{diffr.util.instruction} package. Also in this package, we have implemented classes that deal with transforming instructions to/from text and writing them to streams.

\paragraph{diffr.patch (patch/)} 
This module contains the patch implementation. The algorithm is implemented in \texttt{diffr.patch.Patchr}: it reads both the original file and the patch file into memory. In then uses the classes from the \texttt{util/} module to parse and validate the patch file for existence of incorrect instructions and terminates with an error message if the validation fails. It then iterates through instructions and transforms them into appropriate text. The instruction text is collected in a list and returned. It is the \texttt{diffr.patch.Main} class that outputs the transformed file. This separation of concerns allows us to choose between writing to file and standard output, depending on a flag specified by the user.

Additionally, the patch tool will exit and print a relevant error message if one of the files cannot be read, or if any sort of exception is thrown.

\paragraph{diffr.diff (diff/)}

This module contains the diff implementation. The algorithm is implemented in \texttt{diffr.diff.Diffr}: it builds the \texttt{SuffixTree} or the original file and then iterates through the new file in order to collect in a list the longest sequences of clones and holes between the two files, and return this list. Similarly to \texttt{patch/}, it is the \texttt{diffr.diff.Main} class that outputs the instructions. Again, this separation of concerns allows us to choose between writing to file and standard output, depending on a flag specified by the user.

Also, relevant error messages are printed if any error condition occurs.

\paragraph{diffr.assembly (assembly/)}
This module builds a jar file with all the \texttt{diffr.patch}, \texttt{diffr.diff} classes and their dependencies. The jar file is then aggregated together with bash scripts for running \texttt{diff} and \texttt{patch} in \texttt{.zip} and \texttt{.tar.gz} archives.

\paragraph{diffr.integration-tests (integration-tests/)}
This module contains the integration tests, further described in~\Cref{IntegrationTesting}.

\subsection{Tools}

\paragraph{Build Management}

We used \textit{Maven3} as our build tool. The main advantage of \textit{Maven3} over the more traditional \textit{Ant} is automatic dependency management and default build configuration that suits most of the projects well.

\paragraph{Version Control}
We decided to use \textit{git} as our version control system, as most of our group were already familiar with it. \texttt{git} is great for doing distributed, offline development and the first-class support for branching means we can all safely work in separate branches and freely share code, without polluting the history in the main branch. We also decided to use \textit{bitbucket.org} to host our repository due to the built-in support for issues and pull requests, that we used extensively for planning iterations, tracking tasks and code review.

\paragraph{IDE}
Because we used \textit{Maven3} as our build tool, our team members were free to choose any IDE they wished. Our team members used \textit{IntelliJ IDEA} and \textit{Eclipse}.

\paragraph{Libraries}
We mainly used two open source libraries in the production code: \texttt{javolution}~\cite{javolution} and \texttt{guava-libraries}~\cite{guava}. The already mentioned~\cite{javolution} provided high-performance, real-time replacements for \texttt{Java Collections} classes and~\cite{guava} useful utilities for idiomatically reading/writing files, validating input etc.

