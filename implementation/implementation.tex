\section{Implementation}

In this chapter we will describe the overall architecture of \texttt{diffr} and \texttt{patchr} and provide a few implementation details. Then we will move on to describe the tools we used during the implementation.

\subsection{Modules}

\paragraph{diffr.suffix-tree (suffix-tree/)}
This module contains the Suffix Tree implementation. It is a generic Suffix Tree based on the implementation suggested in \cite{Ukkonen95} and optimised for quickly matching suffixes of elements. The implementation details are completely hidden from the user behind the \texttt{diffr.suffixtree.SuffixTree} interface and \texttt{diffr.suffixtree.SuffixTrees} factory. Using the \texttt{SuffixTree} for matching sequences of elements can be accomplished using an implementation of \texttt{diffr.suffixtree.SuffixTree.Matcher} interface returned from \texttt{SuffixTree\#matcher()} method. Internally the Suffix Tree uses high-performance, real-time \texttt{java.util.List} and \texttt{java.util.Map} implementations from the javolution library (\texttt{javolution.util.FastTable} and \texttt{javolution.util.FastMap})\cite{javolution}. 

\paragraph{diffr.util (util/)}
In this module we placed various domain objects and utility classes. The main classes that encapsulate the two possible instructions output by \texttt{diffr} are located in the \texttt{diffr.util.instruction} package. Also in this package, we have implemented classes that deal with transforming instructions to/from text and writing them to streams.

\paragraph{diffr.patch (patch/)} 
This module is our patch implementation. The algorithm is very simple: it starts by reading in the original file and storing its content to memory. In then uses the methods provided in the util package to grab the next instruction from the patch file. If it is an insert instruction, it prints out the instruction text to standard output. If it is a copy instruction, it fetches the relevant lines and prints them to standard output.

Additionally, the patch tool will exit and print a relevant error message one of the files cannot be read, or if any sort of exception (IO, FileNotFound, etc.) is raised. If the patch file is wrong (e.g. tries to copy non-existing lines), it will also exit.

\paragraph{diffr.diff (diff/)}

This module includes main and \texttt{diffr} classes. The main class parses arguments to two files. These are then passed as arguments to \texttt{diffr} class. In \texttt{diffr}, a \texttt{SuffixTree} of original file is build. This is used to detect the longest sequences of clones between the two files. The \texttt{diffr} class generates a list of instructions that are used by \texttt{patchr}  to transform original file into a new file.

\subsection{Tools}

\paragraph{Build Management}

We used \textit{Maven3} as our build tool. The main advantage of \textit{Maven3} over the more traditional \textit{Ant} is automatic dependency management and default build configuration that suits most of the projects well.

\paragraph{Version Control}
We decided to use \textit{git} as our version control system, as most of our group were already familiar with it. \texttt{git} is great for doing distributed, offline development and the first-class support for branching means we can all safely work in separate branches and freely share code, without polluting the history in the main branch. We also decided to use \textit{bitbucket.org} to host our repository due to the built-in support for issues and pull requests, that we used extensively for planning iterations, tracking tasks and code review.

\paragraph{IDE}
Because we used \textit{Maven3} as our build tool, our team members were free to choose any IDE they wished. Out team members used \textit{IntelliJ IDEA} and \textit{Eclipse}.

